{"title":"“平安报”自动化折腾日记","date":"2020-06-01T00:00:00.000Z","date_formatted":{"ll":"Jun 1, 2020","L":"06/01/2020","MM-DD":"06-01"},"thumbnail":"https://blog-1251959181.cos.accelerate.myqcloud.com/cover/checkInAuto.jpg","link":"2020/05/31/ustb_checkIn_auto","comments":true,"tags":["Note","Original Content"],"categories":["USTB"],"updated":"2024-07-01T17:57:02.538Z","content":"<div class=\"x-sign\" style='width:100%;text-align:center;'>\n    <div>人生最贵是闲暇</div>\n    <div>by 我的发小 Mr.Huyan</div>\n</div>\n<hr>\n<p>感谢<a href=\"https://dashjay.github.io\" target=\"_blank\">DashJay</a>、<a href=\"https://hunsh.net/\" target=\"_blank\">Hunsh</a>、<a href=\"https://jason23347.github.io/\" target=\"_blank\">Json</a>对本栏目的大力支持</p>\n<p>⚠️ <strong>注意，“平安报”上报内容是学校决策的重要参考之一，务必认真对待</strong></p>\n<h2 id=\"概述\">概述<a title=\"#概述\" href=\"#概述\"></a></h2>\n<h3 id=\"系统环境\">系统环境<a title=\"#系统环境\" href=\"#系统环境\"></a></h3>\n<ul>\n<li>MacBook Air (Retina, 13-inch, 2018)</li>\n<li>macOS Catalina 10.15.4</li>\n<li>Charles v4.5.6</li>\n<li>CentOS 7.3 64 位</li>\n</ul>\n<h3 id=\"实现思路\">实现思路<a title=\"#实现思路\" href=\"#实现思路\"></a></h3>\n<p>简单讲就是抓包重放的过程</p>\n<ul>\n<li>抓包工具: <a href=\"https://www.charlesproxy.com/\" target=\"_blank\">Charles</a></li>\n<li>请求重放: Bash 脚本</li>\n<li>定时功能: <a href=\"https://mengmugai.github.io/2018/09/17/CentOS%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E9%85%8D%E7%BD%AE/\" target=\"_blank\">crontab</a></li>\n</ul>\n<hr>\n<h2 id=\"抓包-packet-capture\">抓包 packet capture<a title=\"#抓包-packet-capture\" href=\"#抓包-packet-capture\"></a></h2>\n<p>所谓抓包，可以看作是对“平安报”进行了一次中间人攻击（Man-in-the-Middle Attack, MITM），拿到每天上报数据的 POST 请求，然后直接发请求就可以完成上报了。</p>\n<p>抓包工具我用的是<a href=\"https://www.charlesproxy.com/\" target=\"_blank\">Charles</a>，在使用过程中可能或多或少会遇到一些问题，可以参考以下教程：</p>\n<ul>\n<li>破解版软件与基础配置操作：<a href=\"https://www.jianshu.com/p/633ac6221028\" target=\"_blank\">Charles 使用教程</a></li>\n<li>安装 SSL 证书抓 https 请求：<a href=\"https://blog.csdn.net/a327369238/article/details/52856833\" target=\"_blank\">Mac Charles 乱码解决办法</a></li>\n<li>图文并茂：<a href=\"https://www.jianshu.com/p/8926b8f57cd4\" target=\"_blank\">Charles 手机抓包</a></li>\n</ul>\n<p>最终目的就是找到点击上报时你手机向后台发送的 POST 请求，然后复制 curl 请求<code>copy as cURL</code>。</p>\n<h2 id=\"重放-replay-attacks\">重放 Replay Attacks<a title=\"#重放-replay-attacks\" href=\"#重放-replay-attacks\"></a></h2>\n<p>假设我在咖啡厅花了 25 块钱点了一杯焦糖玛奇朵，而这个请求被黑客拦截了，他就可以通过重放的方式用我的钱给他自己买咖啡；或者我假装我被攻击喝了一个月咖啡后去找银行理赔；<s>再或者</s>禁止套娃</p>\n<p>在这个案例中我们只是用重放节省一些人工成本，那么具体怎么做呢？上一节我们已经找到了提交数据的请求并以<code>curl</code>的形式复制了下来，接下来只需要打开终端并粘贴<code>curl</code>指令回车即可重新发送该请求。</p>\n<p>这时可能有的小伙伴就要问了，那要是剪贴板失效了怎么办呀？所以我们将复制的<code>curl</code>指令保存为 bash 脚本文件：</p>\n<p>新建文件 -&gt; 粘贴指令 -&gt; 保存为<code>curl.sh</code></p>\n<p>这时只需要用<code>bash</code>运行该脚本即可重新发送请求：</p>\n<!-- ![手动运行bash脚本重放请求]() -->\n<img src='https://blog-1251959181.file.myqcloud.com/check-in/curl.jpg'>\n<h2 id=\"定时\">定时<a title=\"#定时\" href=\"#定时\"></a></h2>\n<p>当然了重放攻击也不是那么容易的，有很多避免的方法，“平安报”系统采用了<code>cookie</code>的方式，过期时间为半小时，所以每天定时发送是行不通的，我们要每隔 15 ～ 20 分钟重放一次延长<code>cookie</code>的有效期</p>\n<p>使用 scp 将文件/文件夹上传到服务器：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">传文件</span></span><br><span class=\"line\">scp ~/Desktop/curl.sh root@39.106.76.212:/home</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">传文件夹</span></span><br><span class=\"line\">scp -r ~/Desktop/checkIn root@39.106.76.212:/home/checkIn</span><br></pre></td></tr></table></figure>\n<p>或者在服务器上新建文件并讲内容粘贴进去，由于 curl 请求的内容很长所以需要用到一些 vim 的快捷键如下：(命令模式)</p>\n<ul>\n<li>dd: 删除整行</li>\n<li>^: 跳转到行首</li>\n<li>$: 跳转到行尾</li>\n</ul>\n<p>脚本准备好后可以在服务器上再次执行脚本看下效果，如果收到“今日已上报”到返回数据说明没有问题</p>\n<p>接下来用<code>crontab</code>实现自动重放，常用命令如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -l  # 列出当前的所有调度任务</span><br><span class=\"line\">crontab -e  # 编辑当前用户的配置文件（会打开vim编辑器）</span><br><span class=\"line\">crontab -r  # 删除所有任务调度工作</span><br></pre></td></tr></table></figure>\n<p>在输入<code>crontab -e</code>后，可以在文件中添加任务，每 15 分钟运行一次脚本文件的命令格式如下：</p>\n<figure class=\"highlight shell\"><figcaption><span>/etc/crontab</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*/15 * * * * bash /home/curl.sh</span><br></pre></td></tr></table></figure>\n<!--\ncrontab -e\n*/20 * * * * bash /home/checkIn/checkIn.sh\n -->\n<p>添加定时任务以后就会每 15 分钟发送一次，一劳永逸啦</p>\n<p>关于<code>crontab</code>更详细的教程可以参考<a href=\"https://mengmugai.github.io/2018/09/17/CentOS%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E9%85%8D%E7%BD%AE/\" target=\"_blank\">这篇</a></p>\n<h2 id=\"优化\">优化<a title=\"#优化\" href=\"#优化\"></a></h2>\n<p>大家应该也遇到过在刚过零点的时候会出现”数据库错误“这样的提示，这时<code>cookie</code>是不会续期的，所以如果某天恰好遇到了这种情况，在下次发送的时候<code>cookie</code>就失效了</p>\n<p>当然了你可以选择简单粗暴的办法，每隔 5 分钟重放一次，我就不信 5 次都出错。<s>你这是 DDOS 攻击</s></p>\n<p>所以我们需要优化脚本，如果出错了，就一分钟后再试一次，因为出错的时间一般也就是刚过零点的一小会儿，不会太久。</p>\n<p><s>由于 bash 这东西真不是人写的</s> ，我就不放教程了，我也不是很懂，在<a href=\"https://github.com/Jason23347\" target=\"_blank\">Json</a>的帮助下，这东西还是花了我一天的时间，直接放结果好了</p>\n<p>（Json 这家伙有强迫症，代码可读性极差。<em>所以不要试图理解它，感受它～</em>）</p>\n<figure class=\"highlight bash\"><figcaption><span>checkIn.sh</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># /home/checkIn/checkIn.sh</span></span><br><span class=\"line\">LOG_DIR=/home/checkIn</span><br><span class=\"line\">LOG_FILE=checkIn.<span class=\"built_in\">log</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># open log stream (append)</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 3&gt;&gt;<span class=\"variable\">$LOG_DIR</span>/<span class=\"variable\">$LOG_FILE</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">write_log</span></span>() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span> <span class=\"string\">&quot;[%s] %s\\n&quot;</span> <span class=\"string\">&quot;<span class=\"subst\">$(date +<span class=\"string\">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span>&quot;</span> <span class=\"string\">&quot;<span class=\"variable\">$1</span>&quot;</span> &gt;&amp;3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">mycurl</span></span> () &#123;</span><br><span class=\"line\">    <span class=\"comment\"># 下面要换上你自己的curl请求，保留最后一个反斜杠（执行时忽略换行）</span></span><br><span class=\"line\">    message=`curl -H <span class=\"string\">&#x27;Host: &#x27;</span> -H <span class=\"string\">&#x27;Cookie:&#x27;</span> --data-binary <span class=\"string\">&quot;&quot;</span> --compressed <span class=\"string\">&#x27;&#x27;</span> \\</span><br><span class=\"line\">    -H -L |jq -c <span class=\"string\">&#x27;.message&#x27;</span>` <span class=\"comment\"># 接上文，使用jq拿到返回结果</span></span><br><span class=\"line\">    str=<span class=\"string\">&#x27;&quot;当天已上报You have submitted today.&quot;&#x27;</span></span><br><span class=\"line\">    write_log <span class=\"string\">&quot;<span class=\"variable\">$message</span>&quot;</span></span><br><span class=\"line\">    [ <span class=\"string\">&quot;<span class=\"variable\">$message</span>&quot;</span> == <span class=\"string\">&quot;<span class=\"variable\">$str</span>&quot;</span> ]</span><br><span class=\"line\">    <span class=\"built_in\">return</span> $?  <span class=\"comment\"># 上一个指令的返回值，因为在返回值寄存器里效率比较高</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">mycurl</span><br><span class=\"line\"><span class=\"keyword\">while</span> [ $? -ne 0 ]; <span class=\"keyword\">do</span></span><br><span class=\"line\">    write_log <span class=\"string\">&quot;遇到问题,30s后重试&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">sleep</span> 30</span><br><span class=\"line\">    mycurl</span><br><span class=\"line\"><span class=\"keyword\">done</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># write_log &quot;执行成功&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># close log stream</span></span><br><span class=\"line\"><span class=\"built_in\">exec</span> 3&gt;&amp;-</span><br></pre></td></tr></table></figure>\n<p>以上脚本要安装<code>jq</code>，具体见参考文末链接，运行后查看日志，可以看到已实现稳定的自动上报</p>\n<img src='https://blog-1251959181.file.myqcloud.com/check-in/log.jpg'>\n<blockquote>\n<p>为了简化判断逻辑我没有将上报成功作为正确结果，所以每天上报成功 30s 后会再次执行一次，当返回状态码 300 已上报后开始每 20 分钟执行一次。</p>\n</blockquote>\n<h2 id=\"运维\">运维<a title=\"#运维\" href=\"#运维\"></a></h2>\n<blockquote>\n<p>2021.2.10 所有人的脚本都出了问题，推测是后台服务器重启导致已有 session 全部失效</p>\n</blockquote>\n<p>当 session 出现问题时，如果没配置邮件告警，所有都定时任务的 curl 请求都不会成功，也就是每次都定时任务都会留下一个进程在后台不停的请求，每隔 30s 一次，这时需要我们重新抓包并清空旧进程。</p>\n<p>重新抓包只需要重复上述步骤即可，清理进程步骤如下</p>\n<h3 id=\"linux-下批量杀掉筛选进程\">Linux 下批量杀掉筛选进程<a title=\"#linux-下批量杀掉筛选进程\" href=\"#linux-下批量杀掉筛选进程\"></a></h3>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ps -ef | grep &lt;keyword&gt; | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9</span><br></pre></td></tr></table></figure>\n<p>其中：</p>\n<ul>\n<li><code>|</code> 管道符，用来隔开两个命令，管道符左边命令的输出会作为管道符右边命令的输入。</li>\n<li><code>ps</code> 命令用来列出系统中当前运行的进程，<code>ps -ef</code> 显示所有进程信息，联通命令行。</li>\n<li><code>grep</code> 命令用于过滤/搜索特定字符，<code>grep &lt;keyword&gt;</code> 在这里为搜索过滤所有含某关键字的进程</li>\n<li><code>grep -v grep</code> -v 显示不包含匹配文本的所有行，在这里为筛选出所有不包含 grep 名称的进程，对上一步的进程再做一次筛选(因为 <code>ps -ef</code> 列出了所有的命令，包括命令行)</li>\n<li><code>awk</code> 在文件或字符串中基于指定规则浏览和抽取信息；把文件逐行读入，以空格为默认分隔符将每行切片，然后再进行后序处理。</li>\n<li><code>awk '&#123;print $2&#125;'</code> 将上一步中过滤得到的进程进行打印，<code>$2</code> 表示打印第二个域(PID，进程号) <code>$0</code> 表示所有域,<code>$1</code> 表示第一个域，<code>$n</code> 表示第 n 个域。</li>\n<li><code>xargs</code> 命令是给命令传递参数的过滤器，把标准数据数据转换成命令行参数。在这里则是将获取前一个命令的标准输出然后转换成命令行参数传递给后面的 kill 命令。</li>\n<li><code>kill -9</code> 强制关闭进程。</li>\n</ul>\n<hr>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/m1Ie4gftS79BdtaMp-4eTg\" target=\"_blank\">每日体温自动上报</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/stC6hQ0zyRJtYlA5cOAHQA\" target=\"_blank\">体温 自动 上报</a></li>\n<li><a href=\"https://github.com/Jason23347/hummingbird#pipe-%E7%BC%96%E7%A8%8B%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\" target=\"_blank\">bash 爬虫，爬取小说、漫画等的最新章节，并发送到邮箱</a></li>\n<li><a href=\"https://mengmugai.github.io/2018/09/17/CentOS%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC%E9%85%8D%E7%BD%AE/\" target=\"_blank\">CentOS 定时运行脚本配置</a></li>\n<li><a href=\"https://blog.csdn.net/markximo/article/details/80449626\" target=\"_blank\">CentOS7 安装 jq</a></li>\n</ul>\n","prev":{"title":"Getting Things Done","link":"2020/06/09/share_GTD"},"next":{"title":"Git 学习笔记","link":"2020/05/22/imooc_r_51"},"plink":"https://vincenteliang.com/2020/05/31/ustb_checkIn_auto/","toc":[{"id":"概述","title":"概述","index":"1","children":[{"id":"系统环境","title":"系统环境","index":"1.1"},{"id":"实现思路","title":"实现思路","index":"1.2"}]},{"id":"抓包-packet-capture","title":"抓包 packet capture","index":"2"},{"id":"重放-replay-attacks","title":"重放 Replay Attacks","index":"3"},{"id":"定时","title":"定时","index":"4"},{"id":"优化","title":"优化","index":"5"},{"id":"运维","title":"运维","index":"6","children":[{"id":"linux-下批量杀掉筛选进程","title":"Linux 下批量杀掉筛选进程","index":"6.1"}]},{"id":"参考资料","title":"参考资料","index":"7"}],"reward":true,"copyright":{"author":"Vincente Liang","link":"<a href=\"https://vincenteliang.com/2020/05/31/ustb_checkIn_auto/\" title=\"“平安报”自动化折腾日记\">https://vincenteliang.com/2020/05/31/ustb_checkIn_auto/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"June 1, 2020","updated":"July 1, 2024"},"reading_time":"2014 words in 13 min"}