{"title":"汇编语言实验","date":"2019-11-11T00:00:00.000Z","date_formatted":{"ll":"Nov 11, 2019","L":"11/11/2019","MM-DD":"11-11"},"thumbnail":"https://blog-1251959181.cos.accelerate.myqcloud.com/assembly_language.jpeg","link":"2019/11/10/syl_Assembly_Language","comments":true,"tags":["Note"],"categories":["Coding"],"updated":"2024-07-01T17:57:02.538Z","content":"<style>text{color: #e83e8c;}</style>\n<p><a href=\"https://www.shiyanlou.com/\" target=\"_blank\">实验楼</a>课程笔记——<a href=\"https://www.shiyanlou.com/courses/83\" target=\"_blank\">《汇编语言（第 2 版）》郑晓薇编著配套实验</a></p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/caoyuanll/article/details/50571498\" target=\"_blank\">汇编中一些标志位的含义</a></p>\n</blockquote>\n<h2 id=\"实验一-dos-及-debug-介绍\">实验一 DOS 及 DEBUG 介绍<a title=\"#实验一-dos-及-debug-介绍\" href=\"#实验一-dos-及-debug-介绍\"></a></h2>\n<p>在 DOS 操作系统和 Windows 操作系统中，都提供了调试工具 DEBUG。</p>\n<p>DEBUG 是为汇编语言设计的一种调试工具，它通过单步、设置断点等方式为程序员提供了非常有效的调试手段。利用它可以观察和修改 CPU 的寄存器、内存单元；可以跟踪程序的运行，发现程序的错误。</p>\n<p>实验楼环境中采用 <text>dosemu</text> 来模拟 DOS 环境，进入 DOS 环境中可以直接启动 DEBUG 程序。</p>\n<p>DEBUG 命令有 20 多个，我们主要学习最常用的命令。</p>\n<ul>\n<li><text onclick=\"javascript:document.getElementById('1-R命令-——-查看和修改寄存器').scrollIntoView()\">R</text> ——查看和修改寄存器</li>\n<li><text onclick=\"javascript:document.getElementById('2-D命令-——-查看内存单元').scrollIntoView()\">D</text> ——查看内存单元</li>\n<li><text onclick=\"javascript:document.getElementById('3-E命令-——-修改内存单元').scrollIntoView()\">E</text> ——修改内存单元</li>\n<li><text onclick=\"javascript:document.getElementById('4-U命令-——-反汇编').scrollIntoView()\">U</text> ——反汇编，将机器指令变为汇编指令</li>\n<li><text onclick=\"javascript:document.getElementById('6-T-P命令-——-单步执行').scrollIntoView()\">T/P</text> ——单步执行</li>\n<li><text onclick=\"javascript:document.getElementById('7-G命令-——-连续执行程序').scrollIntoView()\">G</text> ——连续执行程序</li>\n<li><text onclick=\"javascript:document.getElementById('5-A命令-——-输入汇编指令').scrollIntoView()\">A</text> ——输入汇编指令</li>\n<li><text onclick=\"javascript:document.getElementById('8-Q命令-——-退出-DEBUG').scrollIntoView()\">Q</text> ——退出</li>\n</ul>\n<h3 id=\"(1)-r-命令-——-查看和修改寄存器\">(1) R 命令 —— 查看和修改寄存器<a title=\"#(1)-r-命令-——-查看和修改寄存器\" href=\"#(1)-r-命令-——-查看和修改寄存器\"></a></h3>\n<p>R 命令有两种用法：</p>\n<p>直接键入 <text>R</text> —— 将显示 CPU 所有的寄存器和标志位；</p>\n<p>修改寄存器 —— 在 R 后跟写寄存器名（比如 <text>R AX</text>），回车后先显示寄存器的内容，在冒号后键入新的值；再用 R 命令就可看到修改后的内容了。如图所示，使用 <text>R AX</text> 将 AX 寄存器的值改为 1234H。</p>\n<h4 id=\"8086-标志位的缩写形式\">8086 标志位的缩写形式<a title=\"#8086-标志位的缩写形式\" href=\"#8086-标志位的缩写形式\"></a></h4>\n<div class=\"φbq\"><div class=\"φbs\"><table><thead>\n<tr>\n<th style=\"text-align:center\">标志名</th>\n<th style=\"text-align:left\">标志</th>\n<th style=\"text-align:left\">值为 1</th>\n<th style=\"text-align:left\">值为 0</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">进位标志</td>\n<td style=\"text-align:left\"><text>CF</text> carry flag</td>\n<td style=\"text-align:left\"><text>CY</text> CarrY</td>\n<td style=\"text-align:left\"><text>NC</text> No Carry</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">符号标志</td>\n<td style=\"text-align:left\"><text>SF</text> sign flag</td>\n<td style=\"text-align:left\"><text>NG</text> NeGative</td>\n<td style=\"text-align:left\"><text>PL</text> PLus</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">零标志</td>\n<td style=\"text-align:left\"><text>ZF</text> zero flag</td>\n<td style=\"text-align:left\"><text>ZR</text> ZeRo</td>\n<td style=\"text-align:left\"><text>NZ</text> Not Zero</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">溢出标志</td>\n<td style=\"text-align:left\"><text>OF</text> overflow flag</td>\n<td style=\"text-align:left\"><text>OV</text> OVerflow</td>\n<td style=\"text-align:left\"><text>NV</text> No oVerflow</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">辅助进位标志</td>\n<td style=\"text-align:left\"><text>AF</text> auxiliary carry flag</td>\n<td style=\"text-align:left\"><text>AC</text> Auxiliary Carry</td>\n<td style=\"text-align:left\"><text>NA</text> Not Auxiliary carry</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">奇偶标志</td>\n<td style=\"text-align:left\"><text>PF</text> parity flag</td>\n<td style=\"text-align:left\"><text>PE</text> Parity Eve</td>\n<td style=\"text-align:left\"><text>PO</text> Parity Odd</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">方向标志</td>\n<td style=\"text-align:left\"><text>DF</text> direcion flag</td>\n<td style=\"text-align:left\"><text>DN</text> DowN</td>\n<td style=\"text-align:left\"><text>UP</text> up</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">中断标志</td>\n<td style=\"text-align:left\"><text>IF</text> interrupt flag</td>\n<td style=\"text-align:left\"><text>EI</text> Enable Interupt</td>\n<td style=\"text-align:left\"><text>DI</text> Disable Interupt</td>\n</tr>\n</tbody>\n</table></div></div><h3 id=\"(2)-d-命令-——-查看内存单元\">(2) D 命令 —— 查看内存单元<a title=\"#(2)-d-命令-——-查看内存单元\" href=\"#(2)-d-命令-——-查看内存单元\"></a></h3>\n<p>内存每 16 个字节单元为一小段，逻辑段必须从小段的首址开始。用 D 命令可以查看存储单元的地址和内容。</p>\n<p>D 命令格式为：<code>D 段地址:起始偏移地址 [结尾偏移地址] [L范围]</code></p>\n<p>例如：</p>\n<figure class=\"highlight dos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D DS:<span class=\"number\">0</span>          //查看数据段，从<span class=\"number\">0</span>号单元开始</span><br><span class=\"line\">D ES:<span class=\"number\">0</span>          //查看附加段，从<span class=\"number\">0</span>号单元开始</span><br><span class=\"line\">D DS:<span class=\"number\">100</span>        //查看数据段，从<span class=\"number\">100</span>H号单元开始</span><br><span class=\"line\">D <span class=\"number\">0200</span>:<span class=\"number\">5</span> <span class=\"number\">15</span>     //查看<span class=\"number\">0200</span>H段的<span class=\"number\">5</span>号单元到<span class=\"number\">15</span>H号单元（在虚拟机上该命令不能执行）</span><br><span class=\"line\">D <span class=\"number\">0200</span>:<span class=\"number\">5</span> L <span class=\"number\">11</span>   //用L选择范围。查看<span class=\"number\">0200</span>H段的<span class=\"number\">5</span>号单元到<span class=\"number\">15</span>H号单元共<span class=\"number\">17</span>个单元</span><br></pre></td></tr></table></figure>\n<p>如果在 D 后面直接写出偏移地址，则显示当前数据段下偏移地址开始的内存单元，如：</p>\n<figure class=\"highlight dos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D <span class=\"number\">10</span>    //从数据段<span class=\"number\">10</span>H号单元开始显示</span><br><span class=\"line\">D100    //从数据段<span class=\"number\">100</span>H号单元开始显示</span><br></pre></td></tr></table></figure>\n<p>注意：多次键入 D，可连续显示后面的单元内容。</p>\n<h3 id=\"(3)-e-命令-——-修改内存单元\">(3) E 命令 —— 修改内存单元<a title=\"#(3)-e-命令-——-修改内存单元\" href=\"#(3)-e-命令-——-修改内存单元\"></a></h3>\n<p>用 E 命令可以改写多个存储单元的内容。</p>\n<p>格式为：<code>E 起始地址 修改值 修改值...</code></p>\n<p>例如：将数据段中的 DS:3 ～ DS:5 三个单元的内容修改为 14、15、16。命令为</p>\n<figure class=\"highlight dos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E DS:<span class=\"number\">3</span> <span class=\"number\">14</span> <span class=\"number\">15</span> <span class=\"number\">16</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"(4)-u-命令-——-反汇编\">(4) U 命令 —— 反汇编<a title=\"#(4)-u-命令-——-反汇编\" href=\"#(4)-u-命令-——-反汇编\"></a></h3>\n<p>程序员编写的汇编语言源程序经过汇编（编译）后生成了二进制的机器指令代码，而 U 命令可将二进制的机器指令变为助记符形式的汇编指令，因此称之为“反汇编”。通过 U 命令，我们可以得到机器指令与汇编指令的对照，了解机器指令的存储情况。</p>\n<p>注意：多次键入 U，可连续显示后面的程序部分。</p>\n<p>U 后跟偏移地址，则从该地址开始反汇编。如：</p>\n<figure class=\"highlight dos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">U <span class=\"number\">0</span>      //从代码段<span class=\"number\">0</span>号单元开始反汇编</span><br><span class=\"line\">U100     //从代码段<span class=\"number\">100</span>H号单元开始反汇编</span><br></pre></td></tr></table></figure>\n<h3 id=\"(5)-a-命令-——-输入汇编指令\">(5) A 命令 —— 输入汇编指令<a title=\"#(5)-a-命令-——-输入汇编指令\" href=\"#(5)-a-命令-——-输入汇编指令\"></a></h3>\n<p>在 DEBUG 中，使用 A 命令可以输入汇编指令，系统自动地将键入的汇编指令翻译成机器代码，并相继地存放在从指定地址开始的存储区中。由于 DEBUG 下的数值默认为十六进制数，因此先要将十进制数转换成十六进制数。</p>\n<p>例如，计算 Z = 35 + 27 的汇编指令为：</p>\n<figure class=\"highlight dos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV  AX,<span class=\"number\">23</span>H</span><br><span class=\"line\">ADD  AX,<span class=\"number\">1</span>BH</span><br><span class=\"line\">MOV  [<span class=\"number\">0000</span>],AX</span><br></pre></td></tr></table></figure>\n<p>也可以在 A 命令后给出指令的存放地址，如 A CS:0000，表示从代码段的 0 号单元开始存放输入的指令。</p>\n<h3 id=\"(6)-t/p-命令-——-单步执行\">(6) T/P 命令 —— 单步执行<a title=\"#(6)-t/p-命令-——-单步执行\" href=\"#(6)-t/p-命令-——-单步执行\"></a></h3>\n<p>T 命令可以一条一条地执行指令。P 命令的作用与 T 命令相同，当遇到中断指令 INT n 和调用指令 CALL 时，应该使用 P 命令，以确保程序正常执行。这是因为 INT n 指令和 CALL 指令都要转移到子程序去执行，T 命令进入子程序后可能无法返回；而 P 命令则直接执行该指令，并将结果带回。遇到循环指令 LOOP 时也应该使用 P 命令，可以使循环快速结束。</p>\n<h3 id=\"(7)-g-命令-——-连续执行程序\">(7) G 命令 —— 连续执行程序<a title=\"#(7)-g-命令-——-连续执行程序\" href=\"#(7)-g-命令-——-连续执行程序\"></a></h3>\n<p>有关连续执行命令 G 的用法我们放到后面章节中学习。</p>\n<h3 id=\"(8)-q-命令-——-退出-debug\">(8) Q 命令 —— 退出 DEBUG<a title=\"#(8)-q-命令-——-退出-debug\" href=\"#(8)-q-命令-——-退出-debug\"></a></h3>\n<p>键入 Q，回车后退出 DEBUG，返回到 DOS 下。</p>\n<h2 id=\"实验二-指令系统与寻址方式\">实验二 指令系统与寻址方式<a title=\"#实验二-指令系统与寻址方式\" href=\"#实验二-指令系统与寻址方式\"></a></h2>\n<h2 id=\"实验三-汇编语言程序设计\">实验三 汇编语言程序设计<a title=\"#实验三-汇编语言程序设计\" href=\"#实验三-汇编语言程序设计\"></a></h2>\n<h2 id=\"实验四-走向分支\">实验四 走向分支<a title=\"#实验四-走向分支\" href=\"#实验四-走向分支\"></a></h2>\n<h2 id=\"实验五-循环之循环\">实验五 循环之循环<a title=\"#实验五-循环之循环\" href=\"#实验五-循环之循环\"></a></h2>\n<h2 id=\"实验六-子程序与模块化\">实验六 子程序与模块化<a title=\"#实验六-子程序与模块化\" href=\"#实验六-子程序与模块化\"></a></h2>\n<h2 id=\"实验七-宏与多模块\">实验七 宏与多模块<a title=\"#实验七-宏与多模块\" href=\"#实验七-宏与多模块\"></a></h2>\n<h2 id=\"实验八-中断程序设计\">实验八 中断程序设计<a title=\"#实验八-中断程序设计\" href=\"#实验八-中断程序设计\"></a></h2>\n<h2 id=\"实验九-汇编综合实验\">实验九 汇编综合实验<a title=\"#实验九-汇编综合实验\" href=\"#实验九-汇编综合实验\"></a></h2>\n<h2 id=\"实验十-汇编语言教材习题答案\">实验十 汇编语言教材习题答案<a title=\"#实验十-汇编语言教材习题答案\" href=\"#实验十-汇编语言教材习题答案\"></a></h2>\n<p><a href=\"http://www.cppblog.com/merlinfang/archive/2007/06/26/27025.html\" target=\"_blank\">汇编指令大全（有注释）</a></p>\n<p>一、数据传输指令<br>\n───────────────────────────────────────<br>\n它们在存贮器和寄存器、寄存器和输入输出端口之间传送数据.</p>\n<ol>\n<li>通用数据传送指令.<br>\nMOV 传送字或字节.<br>\nMOVSX 先符号扩展,再传送.<br>\nMOVZX 先零扩展,再传送.<br>\nPUSH 把字压入堆栈.<br>\nPOP 把字弹出堆栈.<br>\nPUSHA 把 AX,CX,DX,BX,SP,BP,SI,DI 依次压入堆栈.<br>\nPOPA 把 DI,SI,BP,SP,BX,DX,CX,AX 依次弹出堆栈.<br>\nPUSHAD 把 EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI 依次压入堆栈.<br>\nPOPAD 把 EDI,ESI,EBP,ESP,EBX,EDX,ECX,EAX 依次弹出堆栈.<br>\nBSWAP 交换 32 位寄存器里字节的顺序<br>\nXCHG 交换字或字节.( 至少有一个操作数为寄存器,段寄存器不可作为操作数)<br>\nCMPXCHG 比较并交换操作数.( 第二个操作数必须为累加器 AL/AX/EAX )<br>\nXADD 先交换再累加.( 结果在第一个操作数里 )<br>\nXLAT 字节查表转换.<br>\n── BX 指向一张 256 字节的表的起点, AL 为表的索引值 (0-255,即<br>\n0-FFH); 返回 AL 为查表结果. ( [BX+AL]-&gt;AL )</li>\n<li>输入输出端口传送指令.<br>\nIN I/O 端口输入. ( 语法: IN 累加器, {端口号 │DX} )<br>\nOUT I/O 端口输出. ( 语法: OUT {端口号 │DX},累加器 )<br>\n输入输出端口由立即方式指定时, 其范围是 0-255; 由寄存器 DX 指定时,<br>\n其范围是 0-65535.</li>\n<li>目的地址传送指令.<br>\nLEA 装入有效地址.<br>\n例: LEA DX,string ;把偏移地址存到 DX.<br>\nLDS 传送目标指针,把指针内容装入 DS.<br>\n例: LDS SI,string ;把段地址:偏移地址存到 DS:SI.<br>\nLES 传送目标指针,把指针内容装入 ES.<br>\n例: LES DI,string ;把段地址:偏移地址存到 ES:DI.<br>\nLFS 传送目标指针,把指针内容装入 FS.<br>\n例: LFS DI,string ;把段地址:偏移地址存到 FS:DI.<br>\nLGS 传送目标指针,把指针内容装入 GS.<br>\n例: LGS DI,string ;把段地址:偏移地址存到 GS:DI.<br>\nLSS 传送目标指针,把指针内容装入 SS.<br>\n例: LSS DI,string ;把段地址:偏移地址存到 SS:DI.</li>\n<li>标志传送指令.<br>\nLAHF 标志寄存器传送,把标志装入 AH.<br>\nSAHF 标志寄存器传送,把 AH 内容装入标志寄存器.<br>\nPUSHF 标志入栈.<br>\nPOPF 标志出栈.<br>\nPUSHD 32 位标志入栈.<br>\nPOPD 32 位标志出栈.</li>\n</ol>\n<p>二、算术运算指令<br>\n───────────────────────────────────────<br>\nADD 加法.<br>\nADC 带进位加法.<br>\nINC 加 1.<br>\nAAA 加法的 ASCII 码调整.<br>\nDAA 加法的十进制调整.<br>\nSUB 减法.<br>\nSBB 带借位减法.<br>\nDEC 减 1.<br>\nNEC 求反(以 0 减之).<br>\nCMP 比较.(两操作数作减法,仅修改标志位,不回送结果).<br>\nAAS 减法的 ASCII 码调整.<br>\nDAS 减法的十进制调整.<br>\nMUL 无符号乘法.<br>\nIMUL 整数乘法.<br>\n以上两条,结果回送 AH 和 AL(字节运算),或 DX 和 AX(字运算),<br>\nAAM 乘法的 ASCII 码调整.<br>\nDIV 无符号除法.<br>\nIDIV 整数除法.<br>\n以上两条,结果回送:<br>\n商回送 AL,余数回送 AH, (字节运算);<br>\n或 商回送 AX,余数回送 DX, (字运算).<br>\nAAD 除法的 ASCII 码调整.<br>\nCBW 字节转换为字. (把 AL 中字节的符号扩展到 AH 中去)<br>\nCWD 字转换为双字. (把 AX 中的字的符号扩展到 DX 中去)<br>\nCWDE 字转换为双字. (把 AX 中的字符号扩展到 EAX 中去)<br>\nCDQ 双字扩展. (把 EAX 中的字的符号扩展到 EDX 中去)</p>\n<p>三、逻辑运算指令<br>\n───────────────────────────────────────<br>\n　　 AND 与运算.<br>\nor 或运算.<br>\nXOR 异或运算.<br>\nNOT 取反.<br>\nTEST 测试.(两操作数作与运算,仅修改标志位,不回送结果).<br>\nSHL 逻辑左移.<br>\nSAL 算术左移.(=SHL)<br>\nSHR 逻辑右移.<br>\nSAR 算术右移.(=SHR)<br>\nROL 循环左移.<br>\nROR 循环右移.<br>\nRCL 通过进位的循环左移.<br>\nRCR 通过进位的循环右移.<br>\n以上八种移位指令,其移位次数可达 255 次.<br>\n移位一次时, 可直接用操作码. 如 SHL AX,1.<br>\n移位&gt;1 次时, 则由寄存器 CL 给出移位次数.<br>\n如 MOV CL,04<br>\nSHL AX,CL</p>\n<p>四、串指令<br>\n───────────────────────────────────────<br>\nDS:SI 源串段寄存器 :源串变址.<br>\nES:DI 目标串段寄存器:目标串变址.<br>\nCX 重复次数计数器.<br>\nAL/AX 扫描值.<br>\nD 标志 0 表示重复操作中 SI 和 DI 应自动增量; 1 表示应自动减量.<br>\nZ 标志 用来控制扫描或比较操作的结束.<br>\nMOVS 串传送.<br>\n( MOVSB 传送字符. MOVSW 传送字. MOVSD 传送双字. )<br>\nCMPS 串比较.<br>\n( CMPSB 比较字符. CMPSW 比较字. )<br>\nSCAS 串扫描.<br>\n把 AL 或 AX 的内容与目标串作比较,比较结果反映在标志位.<br>\nLODS 装入串.<br>\n把源串中的元素(字或字节)逐一装入 AL 或 AX 中.<br>\n( LODSB 传送字符. LODSW 传送字. LODSD 传送双字. )<br>\nSTOS 保存串.<br>\n是 LODS 的逆过程.<br>\nREP 当 CX/ECX&lt;&gt;0 时重复.<br>\nREPE/REPZ 当 ZF=1 或比较结果相等,且 CX/ECX&lt;&gt;0 时重复.<br>\nREPNE/REPNZ 当 ZF=0 或比较结果不相等,且 CX/ECX&lt;&gt;0 时重复.<br>\nREPC 当 CF=1 且 CX/ECX&lt;&gt;0 时重复.<br>\nREPNC 当 CF=0 且 CX/ECX&lt;&gt;0 时重复.</p>\n<p>五、程序转移指令<br>\n───────────────────────────────────────</p>\n<ol>\n<li>无条件转移指令 (长转移)<br>\nJMP 无条件转移指令<br>\nCALL 过程调用<br>\nRET/RETF 过程返回.</li>\n<li>条件转移指令 (短转移,-128 到+127 的距离内)<br>\n( 当且仅当(SF XOR OF)=1 时,OP1&lt;OP2 )<br>\nJA/JNBE 不小于或不等于时转移.<br>\nJAE/JNB 大于或等于转移.<br>\nJB/JNAE 小于转移.<br>\nJBE/JNA 小于或等于转移.<br>\n以上四条,测试无符号整数运算的结果(标志 C 和 Z).<br>\nJG/JNLE 大于转移.<br>\nJGE/JNL 大于或等于转移.<br>\nJL/JNGE 小于转移.<br>\nJLE/JNG 小于或等于转移.<br>\n以上四条,测试带符号整数运算的结果(标志 S,O 和 Z).<br>\nJE/JZ 等于转移.<br>\nJNE/JNZ 不等于时转移.<br>\nJC 有进位时转移.<br>\nJNC 无进位时转移.<br>\nJNO 不溢出时转移.<br>\nJNP/JPO 奇偶性为奇数时转移.<br>\nJNS 符号位为 “0” 时转移.<br>\nJO 溢出转移.<br>\nJP/JPE 奇偶性为偶数时转移.<br>\nJS 符号位为 “1” 时转移.</li>\n<li>循环控制指令(短转移)<br>\nLOOP CX 不为零时循环.<br>\nLOOPE/LOOPZ CX 不为零且标志 Z=1 时循环.<br>\nLOOPNE/LOOPNZ CX 不为零且标志 Z=0 时循环.<br>\nJCXZ CX 为零时转移.<br>\nJECXZ ECX 为零时转移.</li>\n<li>中断指令<br>\nINT 中断指令<br>\nINTO 溢出中断<br>\nIRET 中断返回</li>\n<li>处理器控制指令<br>\nHLT 处理器暂停, 直到出现中断或复位信号才继续.<br>\nWAIT 当芯片引线 TEST 为高电平时使 CPU 进入等待状态.<br>\nESC 转换到外处理器.<br>\nLOCK 封锁总线.<br>\nNOP 空操作.<br>\nSTC 置进位标志位.<br>\nCLC 清进位标志位.<br>\nCMC 进位标志取反.<br>\nSTD 置方向标志位.<br>\nCLD 清方向标志位.<br>\nSTI 置中断允许位.<br>\nCLI 清中断允许位.</li>\n</ol>\n<p>六、伪指令<br>\n───────────────────────────────────────<br>\nDW 定义字(2 字节).<br>\nPROC 定义过程.<br>\nENDP 过程结束.<br>\nSEGMENT 定义段.<br>\nASSUME 建立段寄存器寻址.<br>\nENDS 段结束.<br>\nEND 程序结束.</p>\n<p>七、处理机控制指令：<br>\n标志处理指令 CLC（进位位置 0 指令）<br>\nCMC（进位位求反指令）<br>\nSTC（进位位置为 1 指令）<br>\nCLD（方向标志置 1 指令）<br>\nSTD（方向标志位置 1 指令）<br>\nCLI（中断标志置 0 指令）<br>\nSTI（中断标志置 1 指令）<br>\nNOP（无操作）<br>\nHLT（停机）<br>\nWAIT（等待）<br>\nESC（换码）<br>\nLOCK（封锁）</p>\n","prev":{"title":"单片机原理与应用2019","link":"2019/12/28/ustb_CC2530"},"next":{"title":"汇编语言与接口技术2019","link":"2019/11/10/ustb_AL-IO"},"plink":"https://vincenteliang.com/2019/11/10/syl_Assembly_Language/","toc":[{"id":"实验一-dos-及-debug-介绍","title":"实验一 DOS 及 DEBUG 介绍","index":"1","children":[{"id":"(1)-r-命令-——-查看和修改寄存器","title":"(1) R 命令 —— 查看和修改寄存器","index":"1.1"},{"id":"(2)-d-命令-——-查看内存单元","title":"(2) D 命令 —— 查看内存单元","index":"1.2"},{"id":"(3)-e-命令-——-修改内存单元","title":"(3) E 命令 —— 修改内存单元","index":"1.3"},{"id":"(4)-u-命令-——-反汇编","title":"(4) U 命令 —— 反汇编","index":"1.4"},{"id":"(5)-a-命令-——-输入汇编指令","title":"(5) A 命令 —— 输入汇编指令","index":"1.5"},{"id":"(6)-t/p-命令-——-单步执行","title":"(6) T&#x2F;P 命令 —— 单步执行","index":"1.6"},{"id":"(7)-g-命令-——-连续执行程序","title":"(7) G 命令 —— 连续执行程序","index":"1.7"},{"id":"(8)-q-命令-——-退出-debug","title":"(8) Q 命令 —— 退出 DEBUG","index":"1.8"}]},{"id":"实验二-指令系统与寻址方式","title":"实验二 指令系统与寻址方式","index":"2"},{"id":"实验三-汇编语言程序设计","title":"实验三 汇编语言程序设计","index":"3"},{"id":"实验四-走向分支","title":"实验四 走向分支","index":"4"},{"id":"实验五-循环之循环","title":"实验五 循环之循环","index":"5"},{"id":"实验六-子程序与模块化","title":"实验六 子程序与模块化","index":"6"},{"id":"实验七-宏与多模块","title":"实验七 宏与多模块","index":"7"},{"id":"实验八-中断程序设计","title":"实验八 中断程序设计","index":"8"},{"id":"实验九-汇编综合实验","title":"实验九 汇编综合实验","index":"9"},{"id":"实验十-汇编语言教材习题答案","title":"实验十 汇编语言教材习题答案","index":"10"}],"reward":true,"copyright":{"author":"Vincente Liang","link":"<a href=\"https://vincenteliang.com/2019/11/10/syl_Assembly_Language/\" title=\"汇编语言实验\">https://vincenteliang.com/2019/11/10/syl_Assembly_Language/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"November 11, 2019","updated":"July 1, 2024"},"reading_time":"3337 words in 22 min"}