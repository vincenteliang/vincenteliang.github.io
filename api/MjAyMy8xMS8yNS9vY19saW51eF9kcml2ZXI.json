{"title":"在 Linux 系统上实现一个简单的字符设备驱动程序","date":"2023-11-26T00:00:00.000Z","date_formatted":{"ll":"Nov 26, 2023","L":"11/26/2023","MM-DD":"11-26"},"thumbnail":"https://blog-1251959181.cos.accelerate.myqcloud.com/cover/simled.jpg","link":"2023/11/25/oc_linux_driver","comments":true,"tags":["Original Content"],"categories":["Coding"],"updated":"2024-07-01T17:57:02.538Z","content":"<h2 id=\"环境准备\">环境准备<a title=\"#环境准备\" href=\"#环境准备\"></a></h2>\n<ul>\n<li>硬件\n<ul>\n<li>环境: MacBook Pro 14英寸 2023年</li>\n<li>芯片: Apple M2 Pro</li>\n<li>内存: 16 GB</li>\n<li>系统：macOS Sonoma 14.0</li>\n</ul>\n</li>\n<li>软件\n<ul>\n<li>虚拟软件: <a href=\"https://www.parallels.com/products/desktop/\" target=\"_blank\">Parallels Desktop 19 for Mac</a> 商业版 19.1.0 (54729)</li>\n<li>操作系统: <a href=\"https://www.openeuler.org/en/download/?version=openEuler%2022.03%20LTS%20SP2\" target=\"_blank\">OpenEuler 22.03 SP2</a> AArch64 Server <a href=\"https://mirrors.nju.edu.cn/openeuler/openEuler-22.03-LTS-SP2/ISO/aarch64/openEuler-22.03-LTS-SP2-aarch64-dvd.iso\" target=\"_blank\">下载链接</a></li>\n</ul>\n</li>\n</ul>\n<p>在 PD 上安装 OpenEuler 操作系统，系统上已经安装了常用的编译工具，所以无需再次安装。</p>\n<p>可以配置 VScode 无密码登录，开发起来会比较舒服。</p>\n<p>如果遇到报错可以到最后查常见报错及解决办法。</p>\n<h2 id=\"代码编写\">代码编写<a title=\"#代码编写\" href=\"#代码编写\"></a></h2>\n<p>接下来我们要实现一个模拟LED小灯的驱动程序，这个设备有10个LED小灯，我可以输入任意数字，对应的灯会亮起。</p>\n<p>首先先来编写驱动程序 <code>simled.c</code></p>\n<p>在用户文件夹下新建 <code>testdev</code> 文件夹，并新建驱动程序文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root /]<span class=\"comment\"># cd ~</span></span><br><span class=\"line\">[root ~]<span class=\"comment\"># mkdir testdev</span></span><br><span class=\"line\">[root ~]<span class=\"comment\"># cd testdev</span></span><br><span class=\"line\">[root testdev]<span class=\"comment\"># touch simled.c</span></span><br></pre></td></tr></table></figure>\n<p>这时可以继续执行 <code>vi simled.c</code> 并将以下代码输入进去，但这是非常不人道的，所以我们还是在 VSCode 上复制粘贴好了。</p>\n<p>注释版的代码全文在<a href=\"#%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81\">这里</a></p>\n<h3 id=\"基础设施和初始状态\">基础设施和初始状态<a title=\"#基础设施和初始状态\" href=\"#基础设施和初始状态\"></a></h3>\n<h4 id=\"1.-包含头文件\">1. 包含头文件<a title=\"#1.-包含头文件\" href=\"#1.-包含头文件\"></a></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/module.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/fs.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/cdev.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/uaccess.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>#include &lt;linux/module.h&gt;</code>: 包含了编写内核模块所需的各种核心函数和宏定义。</li>\n<li><code>#include &lt;linux/fs.h&gt;</code>: 提供了文件系统的接口，包括用于创建和处理字符设备文件的函数。</li>\n<li><code>#include &lt;linux/cdev.h&gt;</code>: 包含了字符设备的定义和操作函数，用于在内核中注册和管理字符设备。</li>\n<li><code>#include &lt;linux/uaccess.h&gt;</code>: 提供了在用户空间和内核空间之间安全复制数据的函数，如 <code>copy_from_user</code> 和 <code>copy_to_user</code>。</li>\n</ul>\n<h4 id=\"2.-定义宏\">2. 定义宏<a title=\"#2.-定义宏\" href=\"#2.-定义宏\"></a></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DEVICE_NAME <span class=\"string\">&quot;simled&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_COUNT 10</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>#define DEVICE_NAME &quot;simled&quot;</code>: 定义了设备的名称。这个名称通常用于创建设备文件时的标识。</li>\n<li><code>#define LED_COUNT 10</code>: 定义了模拟 LED 的数量。这里模拟了 10 个 LED。</li>\n</ul>\n<h4 id=\"3.-静态全局变量\">3. 静态全局变量<a title=\"#3.-静态全局变量\" href=\"#3.-静态全局变量\"></a></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> major;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> led_state[LED_COUNT + <span class=\"number\">1</span>] = <span class=\"string\">&quot;0000000000&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cdev</span> <span class=\"title\">c_dev</span>;</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"keyword\">class</span> *<span class=\"title\">cl</span>;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>static int major;</code>: 定义了一个静态整型变量 <code>major</code>，用于存储设备的主设备号。在 Linux 中，设备文件通过主设备号和次设备号来识别不同的设备。</li>\n<li><code>static char led_state[LED_COUNT + 1]</code>: 定义并初始化了一个字符数组 <code>led_state</code>，用来表示 LED 的当前状态（亮或灭）。数组的大小是 LED 的数量加一，额外的一个字符用于字符串结束符。</li>\n<li><code>static struct cdev c_dev;</code>: 定义了一个 <code>cdev</code> 结构体 <code>c_dev</code>，在 Linux 内核中，<code>cdev</code> 结构体用于表示字符设备。</li>\n<li><code>static struct class *cl;</code>: 定义了一个指向 <code>class</code> 结构的指针 <code>cl</code>。在设备模型中，<code>class</code> 结构用于将设备和设备文件关联起来。</li>\n</ul>\n<h3 id=\"定义文件操作结构\">定义文件操作结构<a title=\"#定义文件操作结构\" href=\"#定义文件操作结构\"></a></h3>\n<h4 id=\"1.-my_open-函数\">1. my_open 函数<a title=\"#1.-my_open-函数\" href=\"#1.-my_open-函数\"></a></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">my_open</span><span class=\"params\">(<span class=\"keyword\">struct</span> inode *inode, <span class=\"keyword\">struct</span> file *file)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>作用: 当用户程序打开与该设备关联的设备文件时调用这个函数。</li>\n<li>参数:\n<ul>\n<li><code>struct inode *inode</code>: 指向 inode 结构的指针，代表打开的设备文件的内核内部表示。</li>\n<li><code>struct file *file</code>: 指向 file 结构的指针，代表用户程序打开的文件实例。</li>\n</ul>\n</li>\n<li>返回值: 返回 <code>0</code> 表示成功打开设备。</li>\n</ul>\n<h4 id=\"2.-my_close-函数\">2. my_close 函数<a title=\"#2.-my_close-函数\" href=\"#2.-my_close-函数\"></a></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">my_close</span><span class=\"params\">(<span class=\"keyword\">struct</span> inode *inode, <span class=\"keyword\">struct</span> file *file)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>作用: 当用户程序关闭设备文件时调用这个函数。</li>\n<li>参数: 与 <code>my_open</code> 参数作用相同。</li>\n<li>返回值: 返回 <code>0</code> 表示成功关闭设备。</li>\n</ul>\n<h4 id=\"3.-my_read-函数\">3. my_read 函数<a title=\"#3.-my_read-函数\" href=\"#3.-my_read-函数\"></a></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">ssize_t</span> <span class=\"title function_\">my_read</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filep, <span class=\"type\">char</span> __user *buffer, <span class=\"type\">size_t</span> len, <span class=\"type\">loff_t</span> *offset)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> simple_read_from_buffer(buffer, len, offset, led_state, LED_COUNT);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>作用: 用于从设备中读取数据。</li>\n<li>参数:\n<ul>\n<li><code>struct file *filep</code>: 代表打开的文件实例。</li>\n<li><code>char __user *buffer</code>: 用户空间的缓冲区，用于存储从设备读取的数据。</li>\n<li><code>size_t len</code>: 要读取的数据的长度。</li>\n<li><code>loff_t *offset</code>: 文件操作的当前位置偏移量。</li>\n</ul>\n</li>\n<li>功能: 使用 <code>simple_read_from_buffer</code> 函数将 <code>led_state</code> 的内容复制到用户空间的 <code>buffer</code> 中。</li>\n<li>返回值: 返回读取的字节数。</li>\n</ul>\n<h4 id=\"4.-my_write-函数\">4. my_write 函数<a title=\"#4.-my_write-函数\" href=\"#4.-my_write-函数\"></a></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">ssize_t</span> <span class=\"title function_\">my_write</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filep, <span class=\"type\">const</span> <span class=\"type\">char</span> __user *buffer, <span class=\"type\">size_t</span> len, <span class=\"type\">loff_t</span> *offset)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> input;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (copy_from_user(&amp;input, buffer, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EFAULT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (input &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; input &lt; <span class=\"string\">&#x27;0&#x27;</span> + LED_COUNT) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(led_state, <span class=\"string\">&#x27;0&#x27;</span>, LED_COUNT);</span><br><span class=\"line\">        led_state[input - <span class=\"string\">&#x27;0&#x27;</span>] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>作用: 用于向设备写入数据。</li>\n<li>参数:\n<ul>\n<li><code>struct file *filep</code>: 代表打开的文件实例。</li>\n<li><code>const char __user *buffer</code>: 用户空间的缓冲区，包含要写入设备的数据。</li>\n<li><code>size_t len</code>: 要写入的数据的长度。</li>\n<li><code>loff_t *offset</code>: 文件操作的当前位置偏移量。</li>\n</ul>\n</li>\n</ul>\n<!-- - 功能: 将用户空间的数据（buffer）安全地复制 [TODO] -->\n<ul>\n<li>函数体:\n<ul>\n<li><code>char input;</code>: 定义一个字符变量 input 用于存储从用户空间复制的数据。</li>\n<li><code>copy_from_user(&amp;input, buffer, 1)</code>: 将用户空间的数据安全地复制到内核空间。1 表示复制一个字节的数据。</li>\n<li><code>return -EFAULT;</code>: 如果 copy_from_user 失败，则返回错误码。</li>\n<li><code>if</code> 语句: 检查复制的字符是否在有效范围内（代表 LED 的索引）。</li>\n<li><code>memset(led_state, '0', LED_COUNT);</code>: 将所有 LED 状态设置为 ‘0’（关闭）。</li>\n<li><code>led_state[input - '0'] = '1';</code>: 根据输入的字符点亮相应的 LED。</li>\n<li><code>return len;</code>: 返回写入的字节数，表示操作成功。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>在 Linux 内核的字符设备驱动程序中，<code>write</code> 函数的返回值通常用于表示写入操作的结果。返回处理的字符数意味着写入操作成功的几个重要方面：</p>\n<ol>\n<li><strong>成功的数据传输</strong>：返回值表示从用户空间成功复制到内核空间的字符数。如果 <code>write</code> 函数能够返回实际写入的字符数，这意味着数据已成功从用户空间传输到了内核空间。</li>\n<li><strong>用户空间的期望与内核操作的一致性</strong>：用户程序在调用 <code>write</code> 时通常期望能够写入特定数量的数据。<code>write</code> 函数返回实际写入的字符数提供了一种反馈机制，告诉用户程序确切有多少数据被成功处理。如果返回的数量与用户程序请求写入的数量相匹配，这表明写入操作完全符合用户的预期。</li>\n<li><strong>错误检测</strong>：如果在写入过程中发生错误（如无法从用户空间复制数据），<code>write</code> 函数将返回一个错误码（例如 <code>-EFAULT</code>）。这种机制使得用户程序能够检测并适当地响应错误情况。</li>\n<li><strong>符合标准接口的行为</strong>：Linux 系统调用和库函数遵循一定的接口约定。对于 <code>write</code> 系统调用，其预期行为是在成功时返回写入的字节数，在失败时返回错误码。遵循这些约定使得程序更容易理解和维护。</li>\n</ol>\n</blockquote>\n<h4 id=\"5.-文件操作结构-pugs_fops\">5. 文件操作结构 pugs_fops<a title=\"#5.-文件操作结构-pugs_fops\" href=\"#5.-文件操作结构-pugs_fops\"></a></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">pugs_fops</span> =</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    .owner = THIS_MODULE,</span><br><span class=\"line\">    .open = my_open,</span><br><span class=\"line\">    .release = my_close,</span><br><span class=\"line\">    .read = my_read,</span><br><span class=\"line\">    .write = my_write</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这个结构定义了与设备文件相关的操作。它将内核中的函数映射到用户程序执行的系统调用。</p>\n<ul>\n<li>owner = THIS_MODULE: 自动处理模块的使用计数。</li>\n<li>open = my_open: 指定打开设备文件时调用的函数。</li>\n<li>release = my_close: 指定关闭设备文件时调用的函数。</li>\n<li>read = my_read: 指定读取设备文件时调用的函数。</li>\n<li>write = my_write: 指定写入设备文件时调用的函数。</li>\n</ul>\n<h3 id=\"初始化和退出函数\">初始化和退出函数<a title=\"#初始化和退出函数\" href=\"#初始化和退出函数\"></a></h3>\n<h4 id=\"初始化函数\">初始化函数<a title=\"#初始化函数\" href=\"#初始化函数\"></a></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __init <span class=\"title function_\">my_module_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((major = register_chrdev(<span class=\"number\">0</span>, DEVICE_NAME, &amp;pugs_fops)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> major;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((cl = class_create(THIS_MODULE, <span class=\"string\">&quot;chardrv&quot;</span>)) == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        unregister_chrdev(major, DEVICE_NAME);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (device_create(cl, <span class=\"literal\">NULL</span>, MKDEV(major, <span class=\"number\">0</span>), <span class=\"literal\">NULL</span>, DEVICE_NAME) == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        class_destroy(cl);</span><br><span class=\"line\">        unregister_chrdev(major, DEVICE_NAME);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    cdev_init(&amp;c_dev, &amp;pugs_fops);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cdev_add(&amp;c_dev, MKDEV(major, <span class=\"number\">0</span>), <span class=\"number\">1</span>) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        device_destroy(cl, MKDEV(major, <span class=\"number\">0</span>));</span><br><span class=\"line\">        class_destroy(cl);</span><br><span class=\"line\">        unregister_chrdev(major, DEVICE_NAME);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>整个初始化函数是驱动程序的核心，确保设备能够被正确地注册和识别。</p>\n<ul>\n<li>函数头\n<ul>\n<li><code>__init</code> 宏用于告诉内核这个函数仅在模块加载时使用，之后可以释放这部分内存。</li>\n<li><code>my_module_init</code> 是这个初始化函数的名称。</li>\n</ul>\n</li>\n<li>注册字符设备\n<ul>\n<li><code>register_chrdev</code> 函数用于注册一个字符设备。</li>\n<li>第一个参数 <code>0</code> 表示请求内核动态分配一个主设备号。如果您提供了一个非零值，内核将尝试注册您指定的设备号。</li>\n<li><code>DEVICE_NAME</code> 是设备的名称。</li>\n<li><code>&amp;pugs_fops</code> 是一个指向文件操作结构的指针，其中包含了设备操作相关的回调函数（例如：open, read, write等）。</li>\n<li>如果注册失败（返回值小于0），函数返回错误代码。</li>\n</ul>\n</li>\n<li>创建设备类\n<ul>\n<li><code>class_create</code> 函数创建一个新的设备类，该类将出现在 <code>/sys/class</code> 下。</li>\n<li><code>THIS_MODULE</code> 是一个宏，指向当前模块的结构体。</li>\n<li><code>&quot;chardrv&quot;</code> 是这个类的名称。</li>\n<li>如果创建失败，代码将取消之前注册的设备，并返回错误。</li>\n</ul>\n</li>\n<li>创建设备文件\n<ul>\n<li><code>device_create</code> 函数在 <code>/dev</code> 目录下为设备创建节点。</li>\n<li><code>cl</code> 是之前创建的类。</li>\n<li><code>MKDEV(major, 0)</code> 用于创建设备号，其中 <code>major</code> 是主设备号，<code>0</code> 是次设备号。</li>\n<li>如果设备创建失败，代码将销毁设备类并取消注册设备，然后返回错误。</li>\n</ul>\n</li>\n<li>初始化并添加字符设备\n<ul>\n<li><code>cdev_init</code> 用于初始化 <code>c_dev</code> 字符设备结构体，并关联文件操作结构。</li>\n<li><code>cdev_add</code> 将字符设备添加到系统中。</li>\n<li>如果添加失败，代码将撤销之前的操作，并返回错误。</li>\n</ul>\n</li>\n<li>返回值\n<ul>\n<li>如果所有步骤都成功，函数返回 0 表示初始化成功。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"退出函数\">退出函数<a title=\"#退出函数\" href=\"#退出函数\"></a></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __exit <span class=\"title function_\">my_module_cleanup</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    cdev_del(&amp;c_dev);</span><br><span class=\"line\">    device_destroy(cl, MKDEV(major, <span class=\"number\">0</span>));</span><br><span class=\"line\">    class_destroy(cl);</span><br><span class=\"line\">    unregister_chrdev(major, DEVICE_NAME);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>__exit</code> 宏用于标记这个函数仅在模块卸载时使用。对于内建驱动（非模块），这部分代码可能会被忽略以节省空间。</li>\n<li><code>cdev_del(&amp;c_dev);</code>：删除字符设备，撤销 <code>cdev_add</code> 所做的操作。</li>\n<li><code>device_destroy(cl, MKDEV(major, 0));</code>：销毁设备节点，撤销 <code>device_create</code> 所做的操作。</li>\n<li><code>class_destroy(cl);</code>：销毁设备类，撤销 <code>class_create</code> 所做的操作。</li>\n<li><code>unregister_chrdev(major, DEVICE_NAME);</code>：取消注册字符设备，撤销 <code>register_chrdev</code> 所做的操作。</li>\n</ul>\n<h4 id=\"初始化和退出函数的注册\">初始化和退出函数的注册<a title=\"#初始化和退出函数的注册\" href=\"#初始化和退出函数的注册\"></a></h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module_init(my_module_init);</span><br><span class=\"line\">module_exit(my_module_cleanup);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>module_init(my_module_init);</code> 告诉内核使用 <code>my_module_init</code> 函数作为模块的初始化入口点。</li>\n<li><code>module_exit(my_module_cleanup);</code> 告诉内核使用 <code>my_module_cleanup</code> 函数作为模块卸载时的退出入口点。</li>\n</ul>\n<h3 id=\"模块元信息\">模块元信息<a title=\"#模块元信息\" href=\"#模块元信息\"></a></h3>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MODULE_LICENSE(<span class=\"string\">&quot;GPL&quot;</span>);</span><br><span class=\"line\">MODULE_AUTHOR(<span class=\"string\">&quot;Vincente&quot;</span>);</span><br><span class=\"line\">MODULE_DESCRIPTION(<span class=\"string\">&quot;A Simple LED Simulation Driver&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>为模块提供了完整的生命周期管理（初始化和清理），并包含有关模块的重要信息。</p>\n<ul>\n<li><code>MODULE_LICENSE(&quot;GPL&quot;);</code>：指定了模块的许可证。在这里是 GPL，这对于内核模块非常重要，因为它必须与内核的许可证兼容。</li>\n<li><code>MODULE_AUTHOR(&quot;Vincente&quot;);</code>：指定模块的作者。</li>\n<li><code>MODULE_DESCRIPTION(&quot;A Simple LED Simulation Driver&quot;);</code>：提供了对模块的简短描述。</li>\n</ul>\n<h4 id=\"驱动程序完整代码\">驱动程序完整代码<a title=\"#驱动程序完整代码\" href=\"#驱动程序完整代码\"></a></h4>\n<details><summary>点击展开</summary><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/module.h&gt;</span>      <span class=\"comment\">// 包含内核模块的基本定义</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/fs.h&gt;</span>          <span class=\"comment\">// 包含文件系统的处理函数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/cdev.h&gt;</span>        <span class=\"comment\">// 包含字符设备的定义</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;linux/uaccess.h&gt;</span>     <span class=\"comment\">// 包含用户空间和内核空间交互的函数</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DEVICE_NAME <span class=\"string\">&quot;simled&quot;</span>   <span class=\"comment\">// 定义设备的名称</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> LED_COUNT 10           <span class=\"comment\">// 定义模拟 LED 的数量</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> major;              <span class=\"comment\">// 主设备号</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">char</span> led_state[LED_COUNT + <span class=\"number\">2</span>] = <span class=\"string\">&quot;0000000000\\n&quot;</span>; <span class=\"comment\">// 模拟LED状态的字符串</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cdev</span> <span class=\"title\">c_dev</span>;</span>      <span class=\"comment\">// 定义字符设备结构</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"keyword\">class</span> *<span class=\"title\">cl</span>;</span>       <span class=\"comment\">// 设备类指针，用于自动创建设备节点</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 打开设备时调用</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">my_open</span><span class=\"params\">(<span class=\"keyword\">struct</span> inode *inode, <span class=\"keyword\">struct</span> file *file)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 关闭设备时调用</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">my_close</span><span class=\"params\">(<span class=\"keyword\">struct</span> inode *inode, <span class=\"keyword\">struct</span> file *file)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取设备时调用，返回 LED 状态</span></span><br><span class=\"line\"><span class=\"comment\">// filep: 指向文件结构的指针，代表打开的文件实例</span></span><br><span class=\"line\"><span class=\"comment\">// buffer: 指向用户空间缓冲区的指针，用于存储读取的数据</span></span><br><span class=\"line\"><span class=\"comment\">// len: 用户请求读取的数据长度</span></span><br><span class=\"line\"><span class=\"comment\">// offset: 文件中的读取位置偏移量</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">ssize_t</span> <span class=\"title function_\">my_read</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filep, <span class=\"type\">char</span> __user *buffer, <span class=\"type\">size_t</span> len, <span class=\"type\">loff_t</span> *offset)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 simple_read_from_buffer 函数将数据从内核空间复制到用户空间</span></span><br><span class=\"line\">    <span class=\"comment\">// 这个函数处理了数据的复制，并更新了 offset 参数以反映读取的数据量</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> simple_read_from_buffer(buffer, len, offset, led_state, LED_COUNT + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写入设备时调用，根据输入改变 LED 状态</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">ssize_t</span> <span class=\"title function_\">my_write</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filep, <span class=\"type\">const</span> <span class=\"type\">char</span> __user *buffer, <span class=\"type\">size_t</span> len, <span class=\"type\">loff_t</span> *offset)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> input;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (copy_from_user(&amp;input, buffer, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -EFAULT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (input &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; input &lt; <span class=\"string\">&#x27;0&#x27;</span> + LED_COUNT) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(led_state, <span class=\"string\">&#x27;0&#x27;</span>, LED_COUNT);</span><br><span class=\"line\">        led_state[input - <span class=\"string\">&#x27;0&#x27;</span>] = <span class=\"string\">&#x27;1&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> len;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写入设备时调用，根据输入改变 LED 状态</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">ssize_t</span> <span class=\"title function_\">my_write</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *filep, <span class=\"type\">const</span> <span class=\"type\">char</span> __user *buffer, <span class=\"type\">size_t</span> len, <span class=\"type\">loff_t</span> *offset)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> ch;  <span class=\"comment\">// 用于存储从用户空间复制的单个字符</span></span><br><span class=\"line\">    <span class=\"type\">ssize_t</span> i;  <span class=\"comment\">// 循环计数器，记录处理的字符数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历用户提供的每个字符</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将用户空间的数据安全地复制到内核空间</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (copy_from_user(&amp;ch, buffer + i, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -EFAULT; <span class=\"comment\">// 如果复制过程中出错，返回错误</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 检查字符是否表示有效的 LED 索引</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ch &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; ch &lt; <span class=\"string\">&#x27;0&#x27;</span> + LED_COUNT) &#123;</span><br><span class=\"line\">            led_state[ch - <span class=\"string\">&#x27;0&#x27;</span>] = <span class=\"string\">&#x27;1&#x27;</span>; <span class=\"comment\">// 点亮相应的 LED</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> i; <span class=\"comment\">// 返回处理的字符数，表示写入操作的成功</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 文件操作结构，定义了设备支持的操作</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> <span class=\"title\">pugs_fops</span> =</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    .owner = THIS_MODULE,</span><br><span class=\"line\">    .open = my_open,</span><br><span class=\"line\">    .release = my_close,</span><br><span class=\"line\">    .read = my_read,</span><br><span class=\"line\">    .write = my_write</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模块初始化函数</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">int</span> __init <span class=\"title function_\">my_module_init</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 注册字符设备，获得主设备号</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((major = register_chrdev(<span class=\"number\">0</span>, DEVICE_NAME, &amp;pugs_fops)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> major;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建设备类，自动创建设备节点</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((cl = class_create(THIS_MODULE, <span class=\"string\">&quot;chardrv&quot;</span>)) == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        unregister_chrdev(major, DEVICE_NAME);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 创建设备，设备节点位于 /dev/simled</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (device_create(cl, <span class=\"literal\">NULL</span>, MKDEV(major, <span class=\"number\">0</span>), <span class=\"literal\">NULL</span>, DEVICE_NAME) == <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        class_destroy(cl);</span><br><span class=\"line\">        unregister_chrdev(major, DEVICE_NAME);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化字符设备结构</span></span><br><span class=\"line\">    cdev_init(&amp;c_dev, &amp;pugs_fops);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加字符设备到系统</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cdev_add(&amp;c_dev, MKDEV(major, <span class=\"number\">0</span>), <span class=\"number\">1</span>) == <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">        device_destroy(cl, MKDEV(major, <span class=\"number\">0</span>));</span><br><span class=\"line\">        class_destroy(cl);</span><br><span class=\"line\">        unregister_chrdev(major, DEVICE_NAME);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模块清理函数</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span> __exit <span class=\"title function_\">my_module_cleanup</span><span class=\"params\">(<span class=\"type\">void</span>)</span> &#123;</span><br><span class=\"line\">    cdev_del(&amp;c_dev);             <span class=\"comment\">// 删除字符设备</span></span><br><span class=\"line\">    device_destroy(cl, MKDEV(major, <span class=\"number\">0</span>)); <span class=\"comment\">// 销毁设备节点</span></span><br><span class=\"line\">    class_destroy(cl);            <span class=\"comment\">// 销毁设备类</span></span><br><span class=\"line\">    unregister_chrdev(major, DEVICE_NAME); <span class=\"comment\">// 注销设备号</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 指定模块初始化和清理函数</span></span><br><span class=\"line\">module_init(my_module_init);</span><br><span class=\"line\">module_exit(my_module_cleanup);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模块信息</span></span><br><span class=\"line\">MODULE_LICENSE(<span class=\"string\">&quot;GPL&quot;</span>);</span><br><span class=\"line\">MODULE_AUTHOR(<span class=\"string\">&quot;Vincente&quot;</span>);</span><br><span class=\"line\">MODULE_DESCRIPTION(<span class=\"string\">&quot;A Simple LED Simulation Driver&quot;</span>);</span><br></pre></td></tr></table></figure>\n</details><h3 id=\"makefile\">Makefile<a title=\"#makefile\" href=\"#makefile\"></a></h3>\n<p>有了驱动程序以后还要编写对应的 <code>Makefile</code> 文件，内容如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj-m += simled.o</span><br><span class=\"line\">KDIR := /lib/modules/<span class=\"variable\">$(<span class=\"built_in\">shell</span> uname -r)</span>/build</span><br><span class=\"line\">PWD := <span class=\"variable\">$(<span class=\"built_in\">shell</span> pwd)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">default:</span></span><br><span class=\"line\">\t<span class=\"variable\">$(MAKE)</span> -C <span class=\"variable\">$(KDIR)</span> M=<span class=\"variable\">$(PWD)</span> modules</span><br></pre></td></tr></table></figure>\n<h2 id=\"编译测试\">编译测试<a title=\"#编译测试\" href=\"#编译测试\"></a></h2>\n<p>编译前文件夹里应该是这样的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root testdev]<span class=\"comment\"># ls</span></span><br><span class=\"line\">Makefile simled.c</span><br></pre></td></tr></table></figure>\n<h3 id=\"1.-加载驱动程序\">1. <strong>加载驱动程序</strong><a title=\"#1.-加载驱动程序\" href=\"#1.-加载驱动程序\"></a></h3>\n<p>使用 <code>make</code> 命令来编译驱动程序源代码，并使用 <code>insmod</code> 命令来将编译后的模块加载到内核中。(因为我是 root 用户，就没有使用 sudo)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root testdev]<span class=\"comment\"># make</span></span><br><span class=\"line\">[root testdev]<span class=\"comment\"># insmod simled.ko</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2.-检查设备文件\">2. <strong>检查设备文件</strong><a title=\"#2.-检查设备文件\" href=\"#2.-检查设备文件\"></a></h3>\n<p>加载模块后，应该会在 <code>/dev/</code> 目录下创建一个名为 <code>simled</code> 的设备文件。</p>\n<p>使用 <code>ls -l /dev/simled</code> 命令来检查这个文件是否已正确创建。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root testdev]<span class=\"comment\"># ls -l /dev/simled</span></span><br><span class=\"line\">crw-------. 1 root root 242, 0 Nov 28 16:13 /dev/simled</span><br></pre></td></tr></table></figure>\n<h3 id=\"3.-写入测试\">3. <strong>写入测试</strong><a title=\"#3.-写入测试\" href=\"#3.-写入测试\"></a></h3>\n<p>尝试写入不同的值到设备文件中，以测试 LED 状态的更改。</p>\n<p>这可以通过使用 <code>echo</code> 命令和重定向操作来完成。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root testdev]<span class=\"comment\"># echo 3 &gt; /dev/simled</span></span><br></pre></td></tr></table></figure>\n<p>这个命令模拟打开第四个 LED（因为计数是从 0 开始的）。</p>\n<h3 id=\"4.-读取测试\">4. <strong>读取测试</strong><a title=\"#4.-读取测试\" href=\"#4.-读取测试\"></a></h3>\n<p>使用 <code>cat</code> 命令读取设备文件的内容，验证 LED 的状态。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root testdev]<span class=\"comment\"># cat /dev/simled</span></span><br><span class=\"line\">0001000000</span><br></pre></td></tr></table></figure>\n<p>理想情况下，这应该返回一个字符串，其中大部分字符是 ‘0’，并且在第四个位置有一个 ‘1’（表示第四个 LED 为“亮”状态）。</p>\n<h3 id=\"5.-卸载驱动程序\">5. <strong>卸载驱动程序</strong><a title=\"#5.-卸载驱动程序\" href=\"#5.-卸载驱动程序\"></a></h3>\n<p>测试完成后，通过 <code>rmmod</code> 命令卸载驱动程序。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root testdev]<span class=\"comment\"># rmmod simled</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"6.-查看内核日志\">6. <strong>查看内核日志</strong><a title=\"#6.-查看内核日志\" href=\"#6.-查看内核日志\"></a></h3>\n<p>有时，检查 <code>dmesg</code> 命令的输出也很有用，尤其是当您需要调试或查看驱动程序的内核日志消息时。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root testdev]<span class=\"comment\"># dmesg | grep &quot;simled&quot;</span></span><br><span class=\"line\">simled: loading out-of-tree module taints kernel.</span><br><span class=\"line\">simled: module verification failed: signature and/or required key missing - tainting kernel</span><br></pre></td></tr></table></figure>\n","prev":{"title":"效率提高3倍的论文阅读方法","link":"2023/11/28/bilibili_paper_reading"},"next":{"title":"Llama 2 本地部署指南","link":"2023/11/23/oc_run_llama2_local"},"plink":"https://vincenteliang.com/2023/11/25/oc_linux_driver/","toc":[{"id":"环境准备","title":"环境准备","index":"1"},{"id":"代码编写","title":"代码编写","index":"2","children":[{"id":"基础设施和初始状态","title":"基础设施和初始状态","index":"2.1"},{"id":"定义文件操作结构","title":"定义文件操作结构","index":"2.2"},{"id":"初始化和退出函数","title":"初始化和退出函数","index":"2.3"},{"id":"模块元信息","title":"模块元信息","index":"2.4"},{"id":"makefile","title":"Makefile","index":"2.5"}]},{"id":"编译测试","title":"编译测试","index":"3","children":[{"id":"1.-加载驱动程序","title":"1. 加载驱动程序","index":"3.1"},{"id":"2.-检查设备文件","title":"2. 检查设备文件","index":"3.2"},{"id":"3.-写入测试","title":"3. 写入测试","index":"3.3"},{"id":"4.-读取测试","title":"4. 读取测试","index":"3.4"},{"id":"5.-卸载驱动程序","title":"5. 卸载驱动程序","index":"3.5"},{"id":"6.-查看内核日志","title":"6. 查看内核日志","index":"3.6"}]}],"reward":true,"copyright":{"author":"Vincente Liang","link":"<a href=\"https://vincenteliang.com/2023/11/25/oc_linux_driver/\" title=\"在 Linux 系统上实现一个简单的字符设备驱动程序\">https://vincenteliang.com/2023/11/25/oc_linux_driver/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"November 26, 2023","updated":"July 1, 2024"},"reading_time":"4123 words in 27 min"}